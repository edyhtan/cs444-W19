# Assignment 1 Documentation
## Structure of the code
#### Scanner
   1. DFA reads from keywords.txt and lexer.dfa files, constructs a DFA for scanning.
   Keywords.txt contains a list of all keywords in Joos Language and is used to distinguish between keywords and identifiers from token id_keyword.  
   DFA file is defined to be in the following format:
      - number of all states, followed by state names
      - number of accepting states, followed by accepting state names
      - number of transitions, followed by all transition rules
      - each of the rule is defined as follows:
         - current state
         - input (can have up to 2 inputs representing the lower and upper bound of inputs)
         - next state  
  
      For example, `comment$/* 000 127 comment$/*+` means from state `comments$/*` any input character from ascii 0 to ascii 127, the resulting state is `comment$/*+`

   2. Token class contains two fields kind and lexeme. Kind should be one of the symbols and lexeme is the actual content of the input. 

   3. JoosScan reads from an input file and outputs a list of Token or throws an exception. The tokenization is done by maximum munch scanning algorithm in `scan()`. The function returns a valid sequence of tokens if input program is valid, or throws InvalidCharacterException if the input contains character exceeding ASCII 127, or throws InvalidTokenException if the input fails to proceed to an accepting state in the DFA.
   
   4. FileScan is a reader class to read characters one by one and automatically skips line separators.  
    
#### Parser and ParseTree
   1. Grammar contains class definitions for Rule and Transition. It reads the JoosLR1 grammar from grammar.lr1 file generated by JLR and then stores all terminals, nonterminals, rules and transitions in its private fields. `buildTree(tokens)` takes a list of Token and return a ParseTree built based on stack parsing algorithm and JoosLR1 grammar or throws InvalidSyntaxException if syntax error is observed.
   
   2. ParseTree defines the recursive structure of a parse tree:
      - kind, lexeme stores information of the current node
      - children is of type List\<ParseTree> and contains the subtree of the current node  

      Note that for special kinds separator, operator and keyword, the parse tree stores it's lexeme for the convenience of tree interpretation and debugging, other wise kind stores the name of the kind.

   3. JoosParse contains a Grammar field JoosGrammar and a ParseTree field tree. `parse()` invokes `Grammar.buildTree(tokens)` and checks if the tree build is acceptable. `parse()` throws InvalidSyntaxException at this point if tree building failed. If the tree is acceptable, then `preASTWeeding()` explicitly checks for  invalid casting problem in the tree and throws InvalidParseTreeException if bad casting is observed.  

#### Weeder and AST
1. AST is built in a way such that the most informative nodes in the parse tree and remove the others. For example, `AST/Constants/RecursionResolve.resolveName()` recursively removes Name nodes, only keeps SimpleName and QualifiedName and stores in a list. `resolveNodes()` are used to resolve other types of nodes. 
   
2. Most parts of weeding, such as modifiers checking and fields' initializer, are implemented based on the AST constructed. `JoosAST.checkFileName()` explicitly checks that a class/interface must be declared in a .java file with the same base name as the class/interface. All input characters' range have already been checked in DFA already.

#### Main Class
Joosc is the main class that does the scanning, parsing and weeding in order, and handles all exceptions with return values.

## Challenges 
1. Casting and parenthesis expression
   The parser initially allows invalid type casts using rule `CastExpression ( Expression ) UnaryExpressionNotMinus`. Since Expression can be further reduced to PostFixExpression and then to Names (including SimpleName and QuantifiedName), it can be ambiguous to cast a statement in such way. The function `JoosParse.preASTWeeding()` is implemented explicitly to handle such a problem. Once we obtain a valid parse tree after parsing, then `preASTWeeding()` explicitly checks for invalid casting problem in the tree and throws InvalidParseTreeException if bad casting is observed.  
   For example, `Object y = (x.foo()) x;` is a bad casting since method invocation not allowed as type in cast. InvalidParseTreeException is expected here and input is rejected.

2. Building AST
   It is hard to analyze and decide which nodes should be removed from the parse tree in general. We had to look at each rule and consider whether information should be preserved and a class is needed. At this point of the project, we are only implementing part of the AST nodes for weeding integer ranges, control flow keywords break, continue inside while/for loop blocks. The rest of the nodes will be completed after due date.


## Tests 
Test cases were created based each of the valid feature listed on *The Joos Languages* page. Each feature is first tested individually first before moving on to complicated cases. Each isolated test case is named after \<FeatureName>.java.   
After all single valid cases are passed, some more complicated test programs were created to contain a mixture of single valid cases. 
Finally, we have tested on invalid cases to make sure exceptions were threw and caught as expected.  

## Acknowledgement
The LR1 grammar was designed based on *The Java Language Specification, version 1.0* (https://www.cs.cornell.edu/andru/javaspec/19.doc.html) as a starting point, combined with *The Joos Languages* and removes unsupported features. 
